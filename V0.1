!pip install tweepy --upgrade #This will update the tweepy to the last version if it is outdated

import tweepy
import time
import random
import sqlite3
from transformers import pipeline
from datetime import datetime

# ---------------------- CONFIGURATION ---------------------- #
API_KEY = "aJGu4M5yOdPxaNlfvJ0bTkw2o"
API_SECRET = "5hUkhQ4k69wpi1kxSHU0TwXteCflEghlry4U1RmbOZFyJX3r9t"
ACCESS_TOKEN = "1894174463119495168-Ec1dMFBLIwKxd9PTGEr4CIm8ATP2nV"
ACCESS_TOKEN_SECRET = "usJFhBfund2ol8K0kMVIPE6F7J4QwsfIE242PoCMBgdJ7"

# Topics to track
TRACK_KEYWORDS = ["cryptomonnaie", "Web3", "Blockchain", "Politique", "technologies"]
MAX_TWEETS_PER_DAY = 50  # Limitation pour Ã©viter les blocages
TWEET_INTERVAL = 60 * 30  # 30 minutes entre chaque tweet

# ---------------------- INITIALISATION ---------------------- #
# Authentification Twitter
auth = tweepy.OAuthHandler(API_KEY, API_SECRET)
auth.set_access_token(ACCESS_TOKEN, ACCESS_TOKEN_SECRET)
api = tweepy.API(auth, wait_on_rate_limit=True)

# Chargement des pipelines pour l'analyse de sentiment et rÃ©sumÃ©
sentiment_analyzer = pipeline("sentiment-analysis")
summarizer = pipeline("summarization")

# Base de donnÃ©es locale pour stocker les tweets traitÃ©s
conn = sqlite3.connect('tweets.db')
c = conn.cursor()
c.execute('''CREATE TABLE IF NOT EXISTS processed_tweets (id TEXT PRIMARY KEY, date TEXT)''')
conn.commit()

# ---------------------- FONCTIONS ---------------------- #
def tweet_already_processed(tweet_id):
    c.execute("SELECT id FROM processed_tweets WHERE id=?", (tweet_id,))
    return c.fetchone() is not None

def save_tweet(tweet_id):
    c.execute("INSERT INTO processed_tweets (id, date) VALUES (?, ?)", (tweet_id, datetime.now().strftime('%Y-%m-%d %H:%M:%S')))
    conn.commit()

def analyze_and_summarize(tweet_text):
    sentiment = sentiment_analyzer(tweet_text)[0]
    summary = summarizer(tweet_text, max_length=50, min_length=20, do_sample=False)[0]['summary_text']
    return sentiment, summary

def post_tweet(content):
    try:
        api.update_status(content)
        print(f"âœ… Tweet publiÃ©: {content}")
    except Exception as e:
        print(f"ðŸš« Erreur lors de la publication du tweet: {e}")

# ---------------------- STREAMING ---------------------- #
class MyStreamListener(tweepy.StreamingClient): # Change here: Inherit from tweepy.StreamingClient instead of tweepy.StreamListener
    def on_tweet(self, status):  # Change here: Override on_tweet instead of on_status
        if hasattr(status, "retweeted_status") or status.author_id == api.verify_credentials().id: # Change here: Use author_id and verify_credentials
            return  # Ignorer les retweets et ses propres tweets

        tweet_id = status.id
        if tweet_already_processed(tweet_id):
            print("Tweet dÃ©jÃ  traitÃ©. IgnorÃ©.")
            return

        print(f"\nðŸ”Ž Nouveau tweet trouvÃ©: {status.text}")
        sentiment, summary = analyze_and_summarize(status.text)

        tweet_content = (
            f"ðŸ“° RÃ©sumÃ©: {summary}\n"
            f"ðŸ’¬ Sentiment: {sentiment['label']} ({round(sentiment['score'] * 100, 2)}%)\n"
            f"ðŸ”— https://twitter.com/{status.user.screen_name}/status/{tweet_id}"
        )

        post_tweet(tweet_content)
        save_tweet(tweet_id)
        time.sleep(random.uniform(TWEET_INTERVAL - 60, TWEET_INTERVAL + 60))

    def on_error(self, status_code):
        if status_code == 420:
            print("ðŸš« Limite de taux atteinte. Pause activÃ©e.")
            time.sleep(60 * 15)
            return False

# ---------------------- LANCEMENT ---------------------- #
if __name__ == "__main__":
    print("ðŸš€ Agent Twitter AI dÃ©marrÃ©.")
    stream_listener = MyStreamListener(bearer_token='YOUR_BEARER_TOKEN') # Change here: Initialize StreamingClient with bearer token
    
    try:
        stream_listener.filter(track=TRACK_KEYWORDS, languages=["fr"]) # Change here: Call filter on the listener instance
    except KeyboardInterrupt:
        print("ðŸ”´ ArrÃªt manuel de l'agent.")
    finally:
        conn.close()
        print("ðŸ’¾ Connexion Ã  la base de donnÃ©es fermÃ©e.")
